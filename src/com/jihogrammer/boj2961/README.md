###### [*Home*](../../../../README.md) / [*BOJ*](../../../../BAEKJOON.md) / *2961*

# [백준 2961] 도영이가 만든 맛있는 음식

<details>
    <summary>
        <i><strong>Problem - <a href="https://www.acmicpc.net/problem/2961">@BOJ</a></strong></i>
    </summary>
    <h2><i>Problem</i></h2>
    <p>
        도영이는 짜파구리 요리사로 명성을 날렸었다. 이번에는 이전에 없었던 새로운 요리에 도전을 해보려고 한다.
    <br>
        지금 도영이의 앞에는 재료가 N개 있다. 도영이는 각 재료의 신맛 S와 쓴맛 B를 알고 있다. 여러 재료를 이용해서 요리할 때, 그 음식의 신맛은 사용한 재료의 신맛의 곱이고, 쓴맛은 합이다.
    <br>
        시거나 쓴 음식을 좋아하는 사람은 많지 않다. 도영이는 재료를 적절히 섞어서 요리의 신맛과 쓴맛의 차이를 작게 만들려고 한다. 또, 물을 요리라고 할 수는 없기 때문에, 재료는 적어도 하나 사용해야 한다.
    <br>
        재료의 신맛과 쓴맛이 주어졌을 때, 신맛과 쓴맛의 차이가 가장 작은 요리를 만드는 프로그램을 작성하시오.
    </p>
    <h2><i>Input</i></h2>
    <p>
        첫째 줄에 재료의 개수 N(1 ≤ N ≤ 10)이 주어진다. 다음 N개 줄에는 그 재료의 신맛과 쓴맛이 공백으로 구분되어 주어진다. 모든 재료를 사용해서 요리를 만들었을 때, 그 요리의 신맛과 쓴맛은 모두 1,000,000,000보다 작은 양의 정수이다.
    </p>
    <h2><i>Output</i></h2>
    <p>
        첫째 줄에 신맛과 쓴맛의 차이가 가장 작은 요리의 차이를 출력한다. 
    </p>
    <h2><i>Example</i></h2>
    <h3><i>in</i></h3>
    <pre><code>4
1 7
2 6
3 8
4 9</code></pre>
    <h3><i>out</i></h3>
    <pre><code>1</code></pre>
    <h2><i>Hint</i></h2>
    <p>
        2, 3, 4번 재료를 사용한다면, 요리의 신맛은 2×3×4=24, 쓴맛은 6+8+9=23이 된다. 차이는 1이다.
    </p>
</details>

## *Solution*

|No |Concept                 |Memory   |Time   |Code Length|
|:-:|:-----------------------|---------|-------|-----------|
|1  |[bitmask & Power Set][1]| 14260 KB| 124 ms|     1217 B|

식재료를 집합으로 생각했을 때, 식재료를 **하나 이상 사용**해야 하므로 **공집합을 제외한 모든 부분집합을 탐색**하여 최적의 맛을 구해야 합니다.

#### 생각할 수 있는 다른 풀이

* 재귀(DFS)

<a id="sol1"></a>

### *bitmask & Power Set*

* [***Full Code***](http://boj.kr/48845d13bf0f4a4284995787d2dd2b02)

1. ***init_BOJ2961()***
    ```java
    int c; // 수를 입력 받기 위해 잠시 사용하는 변수

    while ((c = System.in.read()) > 13) N = 10 * N + (c - '0');
    // System.in.read(); -> 백준에서는 지우고, IDE에서는 사용해야 함

    S = new int[N];
    B = new int[N];
    flavorDiff = Integer.MAX_VALUE;
    ```
    1. `N`은 `Main` 클래스의 **멤버변수**이므로 0으로 초기화 되어 있습니다.
    2. **표준입력**(`System.in`)을 그대로 사용하여 `N`값을 입력받습니다.
    3. 주어진 `N`만큼의 크기를 가진 **신맛**(`S`), **쓴맛**(`B`) 배열을 생성합니다.
    4. **신맛**과 **쓴맛**의 차이를 저장할 변수(`flavorDiff`)를 초기화합니다.

2. ***ready()***
    ```java
    int c; // 수를 입력 받기 위해 잠시 사용하는 변수

    for (int i = 0; i < N; i++) {

        while ((c = System.in.read()) > 32)
            S[i] = 10 * S[i] + (c - '0');
        while ((c = System.in.read()) > 13)
            B[i] = 10 * B[i] + (c - '0');
        // System.in.read(); -> 백준에서는 지우고, IDE에서는 사용해야 함

    }
    ```
    1. **표준입력**(`System.in`)을 그대로 사용하여 맛의 수치를 입력받아 신맛, 쓴맛 배열을 초기화 합니다.

3. ***bestIngredients(1<<N)***
    ```java
    for (int flag = 1; flag < caseCount; flag++) {

        int s = 1; // 신맛 수치를 임시 저장할 변수; 곱의 항등원 1
        int b = 0; // 쓴맛 수치를 임시 저장할 변수; 합의 항등원 0

        for (int i = 0; i < N; i++) { // 전체 재료를 탐색하여

            if ((flag & 1<<i) > 0) { // bitmask를 통과하면
                s *= S[i];           // 신맛 수치 갱신
                b += B[i];           // 쓴맛 수치 갱신
            }

        }

        // s-b의 절댓값과 기존 맛격차를 비교하여 최솟값 갱신
        flavorDiff = Math.min(flavorDiff, Math.abs(s-b));

    }
    ```
    1. 매개변수로 `1<<N`(함수 내에서는 `caseCount`)을 받는데, 이는 ***bitmask***로 **부분집합**을 사용하기 위함입니다.
    2. 아직까지 ***bitmask***를 완벽하게 설명할 자신은 없기 때문에 간략하게만 설명하자면, 각 자리 **bit** 값(0 또는 1)을 비교하여 재료에 포함시킬지 말지를 결정합니다.
    3. **outer for** - 부분집합으로서 포함시킬 원소의 개수
        * `flag`가 0이면 **공집합**을 의미하므로 이를 피하기 위해 **1부터 시작**합니다.
    4. **inner for** - 모든 재료를 탐색하나 `flag`에서 걸러짐
        * `flag` 조건을 통과하면 맛을 갱신합니다.
    5. **inner for**문을 통과하면 부분집합 하나를 통과한 것이므로 맛차이를 갱신합니다.

<!-- ref -->
[1]: #sol1
